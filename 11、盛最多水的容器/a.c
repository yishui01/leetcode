int maxArea(int* height, int heightSize) {
    //数组中每两个数字都要进行一次计算,返回是int，那就是返回容量咯
    //好吧双重循环时间超时，很尴尬，用了双指针算法，很巧妙
	//1、左右两指针指向两端点
	//2、将高度较矮的指针向中间移动，直到两指针相遇，为什么移动较矮指针？
	//分析：如果移动高的，移动完之后分三种情况，
	//一、比原来矮的还矮，那么横轴变短，盛水高度也变矮，容量变小（盛水高度以矮板子为准）
	//二、和原来矮的一样高，横轴变短，高度不变，容量变小
	//三、比原来矮的要高，横轴变短，高度不变，容量变小
	//3、分析完，想要容量变大，只能移动矮的板子，不能动高的，但是这样移动会不会错过最佳组合？
	//一开始我也纳闷，后来想了想，是不会错过最佳组合的，因为我们最大水量反正保存在变量中
	//每次指针移动都会比较之后再更新。下面是反证法，假设最大容量是pleft和pright的时候触发。
	//假设在左指针还在pleft左边的时候，右指针已经移动超过了pright，那么问题来了
	//也就是说右指针是已经经过pright了，那么在它刚刚到达pright的时候，左指针还在pleft的左边
	//横轴比最大容量时的横轴要长，而且此时的左指针竟然使右指针发生了移动，也就是说此时左指针高度
	//大于右指针，问题来了，开始的假设是pleft和pright时容量最大，假设pright高度小于pleft，
	//盛水高度就是pright，
	//那么此时出现的情况是，之前还有一个组合横轴大于最大容量的横轴，而且盛水高度反正不比pright矮，
	//（因为左指针使右指针发生移动,所以左要高于右）
	//也就是说之前还有个组合比你这个最大组合要大，自相矛盾，所以不存在这种情况。
	//（如果pleft<pright更不用说了，现在这组合整体高度比pright还高呢）
    int res = 0, left = 0, right = heightSize - 1, temp = 0;
    
    //双指针算法，向中间移动较矮的那一个指针，直到两指针相遇
    while (right > left) {
        temp = height[left] > height[right] ? (right-left)* height[right] : (right-left)* height[left];
        res = temp > res ? temp : res;
        height[left] >= height[right] ? right-- : left++;
    }
    
    return res;
    
}