func firstMissingPositive(nums []int) int {
    //O(n)+常量空间，不看答案没有思路系列
    //第一次遍历，将值swap到对应的索引下，比如5就要放到4号位,最终交换完成的数组看起来像这样，[1,2,3,4...]
    //这里有个问题，如果一直i++, 被交换的那个数字就会漏掉，比如第一个元素是3，第3个元素是2，i=1时把3交换到2那里，然后2放到了第一个元素中，
    //此时进入下一个循环，i已经到第二个元素了，被交换过来的2就被漏了，没人管，要解决这样问题，就是要照顾被交换过来的元素，那么
    //看到一个最强方案是交换时不自增i，这样下一次循环还是从当前点开始了，厉害了，只有不发生交换时才进入下一个元素
    //当然为了避免无限循环，要判断交换位和被交换位是否重复，重复就不用交换了
    
    //第二次遍历，就是找那个位置没有对应的索引，那个就是最小miss
    
    lens := len(nums)
    for i:=0 ; i < lens; {
        if nums[i] != i+1 && nums[i]-1 >=0 && nums[i]-1 < lens && nums[nums[i]-1] != nums[i]{
            //交换，把当前的元素放到他该有的位置上，当然，如果他那个位置上有个相同值的元素，就不用换了
            tmp := nums[nums[i]-1]
            nums[nums[i]-1] = nums[i]
            nums[i] = tmp
        } else {
             i++
         }
      
    }
    
    for i := 0; i < lens; i++ {
        if nums[i] != i+1 {
            return i+1
        }
    }
   
    return lens+1
    
    
    
}
