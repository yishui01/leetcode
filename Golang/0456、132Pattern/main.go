func find132pattern(nums []int) bool {
    //单调栈，居然可以这么用，佛了
    //132 ，栈里面保存3，就是最大的那个，但这个数字在排列顺序上是第二位
    //从后往前遍历，不要问为什么，因为这样恰好能满足 32的排列顺序，继续看
    //遍历到的数字尝试添加到栈中，栈顶到栈底为从小到大排列，这样看遇到的数字是否小于栈顶数字，小于直接push进去，相等直接跳过，没用
    //遇到大于栈顶的，那么就循环pop出栈顶元素，直到新元素成为栈顶，保持栈的单调递增，从栈顶往下是递增
    //那么pop出来的这些元素，不断的迭代到外部的一个变量A，这个变量A随着不断pop，他会越来越大，但是栈里面的数字更大
    //那么外面的这个数字A实际上就是之前栈里面的数字pop出来的，就是在排列顺序上，是在栈顶元素的右边，并且值还要小于栈顶元素
    //那么这个A是不是就是132中的2，栈顶元素就是132中的3，这个3在排列顺序上是在左边，还把原来的栈顶元素给挤(pop)出去了，挤出去的都是比他小的
    //那么找到32组合之后还有个1没找到，找1其实就是在遍历的过程中判断当前数字是不是小于A，当然了，A初始值为MinInt64,只要不迭代A，是不可能出现小于A的数的
    //一旦迭代了A，说明已经生成了32组合，因为只有新元素入栈并pop老元素，才会赋值给A。

    stack := make([]int,0)
    two := math.MinInt64

    for i:=len(nums)-1;i>=0;i--{
        if nums[i] < two {
            return true
        }
        for len(stack) != 0 && stack[len(stack)-1] < nums[i] {
            two = stack[len(stack)-1]
            stack = stack[:len(stack)-1]
        }
        stack = append(stack,nums[i])
    }

    return false
}
